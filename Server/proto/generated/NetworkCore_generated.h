// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKCORE_MMO_NETWORK_H_
#define FLATBUFFERS_GENERATED_NETWORKCORE_MMO_NETWORK_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace MMO {
namespace Network {

struct Ping;
struct PingBuilder;

struct Login;
struct LoginBuilder;

struct Envelope;
struct EnvelopeBuilder;

enum Opcode : uint16_t {
  Opcode_None = 0,
  Opcode_C2S_Ping = 1,
  Opcode_S2C_Pong = 2,
  Opcode_C2S_Login = 100,
  Opcode_C2S_MoveRequest = 1000,
  Opcode_S2C_MovementSnapshot = 1001,
  Opcode_C2S_AttackTarget = 2000,
  Opcode_MIN = Opcode_None,
  Opcode_MAX = Opcode_C2S_AttackTarget
};

inline const Opcode (&EnumValuesOpcode())[7] {
  static const Opcode values[] = {
    Opcode_None,
    Opcode_C2S_Ping,
    Opcode_S2C_Pong,
    Opcode_C2S_Login,
    Opcode_C2S_MoveRequest,
    Opcode_S2C_MovementSnapshot,
    Opcode_C2S_AttackTarget
  };
  return values;
}

inline const char *EnumNameOpcode(Opcode e) {
  switch (e) {
    case Opcode_None: return "None";
    case Opcode_C2S_Ping: return "C2S_Ping";
    case Opcode_S2C_Pong: return "S2C_Pong";
    case Opcode_C2S_Login: return "C2S_Login";
    case Opcode_C2S_MoveRequest: return "C2S_MoveRequest";
    case Opcode_S2C_MovementSnapshot: return "S2C_MovementSnapshot";
    case Opcode_C2S_AttackTarget: return "C2S_AttackTarget";
    default: return "";
  }
}

struct Ping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct PingBuilder {
  typedef Ping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Ping::VT_TIMESTAMP, timestamp, 0);
  }
  explicit PingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ping> CreatePing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0) {
  PingBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct Login FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoginBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERNAME = 4
  };
  const ::flatbuffers::String *username() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERNAME) &&
           verifier.VerifyString(username()) &&
           verifier.EndTable();
  }
};

struct LoginBuilder {
  typedef Login Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_username(::flatbuffers::Offset<::flatbuffers::String> username) {
    fbb_.AddOffset(Login::VT_USERNAME, username);
  }
  explicit LoginBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Login> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Login>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Login> CreateLogin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> username = 0) {
  LoginBuilder builder_(_fbb);
  builder_.add_username(username);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Login> CreateLoginDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *username = nullptr) {
  auto username__ = username ? _fbb.CreateString(username) : 0;
  return MMO::Network::CreateLogin(
      _fbb,
      username__);
}

struct Envelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE = 4,
    VT_PAYLOAD_DATA = 6
  };
  MMO::Network::Opcode opcode() const {
    return static_cast<MMO::Network::Opcode>(GetField<uint16_t>(VT_OPCODE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *payload_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OPCODE, 2) &&
           VerifyOffset(verifier, VT_PAYLOAD_DATA) &&
           verifier.VerifyVector(payload_data()) &&
           verifier.EndTable();
  }
};

struct EnvelopeBuilder {
  typedef Envelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_opcode(MMO::Network::Opcode opcode) {
    fbb_.AddElement<uint16_t>(Envelope::VT_OPCODE, static_cast<uint16_t>(opcode), 0);
  }
  void add_payload_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload_data) {
    fbb_.AddOffset(Envelope::VT_PAYLOAD_DATA, payload_data);
  }
  explicit EnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Envelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Envelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Envelope> CreateEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MMO::Network::Opcode opcode = MMO::Network::Opcode_None,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload_data = 0) {
  EnvelopeBuilder builder_(_fbb);
  builder_.add_payload_data(payload_data);
  builder_.add_opcode(opcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Envelope> CreateEnvelopeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MMO::Network::Opcode opcode = MMO::Network::Opcode_None,
    const std::vector<uint8_t> *payload_data = nullptr) {
  auto payload_data__ = payload_data ? _fbb.CreateVector<uint8_t>(*payload_data) : 0;
  return MMO::Network::CreateEnvelope(
      _fbb,
      opcode,
      payload_data__);
}

inline const MMO::Network::Envelope *GetEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<MMO::Network::Envelope>(buf);
}

inline const MMO::Network::Envelope *GetSizePrefixedEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MMO::Network::Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MMO::Network::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MMO::Network::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MMO::Network::Envelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MMO::Network::Envelope> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Network
}  // namespace MMO

#endif  // FLATBUFFERS_GENERATED_NETWORKCORE_MMO_NETWORK_H_
